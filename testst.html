<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Classic Star Trek Game (JavaScript)</title>
<style>
  body {
    font-family: monospace;
    background: #000;
    color: #0f0;
    margin: 0; padding: 0;
  }
  #game-container {
    display: flex;
    flex-direction: column;
    height: 100vh;
  }
  #output {
    flex: 1;
    background: #000;
    color: #0f0;
    overflow-y: auto;
    white-space: pre;
    padding: 10px;
  }
  #input-area {
    display: flex;
    background: #111;
    padding: 10px;
  }
  #command-input {
    flex: 1;
    background: #222;
    color: #0f0;
    border: 1px solid #0f0;
    font-family: monospace;
    font-size: 16px;
    padding: 5px;
  }
  #submit-btn {
    background: #333;
    color: #0f0;
    border: 1px solid #0f0;
    margin-left: 10px;
    cursor: pointer;
    font-family: monospace;
    padding: 5px 10px;
  }
  #prompt-container {
    background: #111;
    padding: 10px;
    display: none;
    flex-direction: column;
  }
  #prompt-message {
    margin-bottom: 5px;
  }
  #prompt-input {
    background: #222;
    color: #0f0;
    border: 1px solid #0f0;
    font-family: monospace;
    padding: 5px;
    margin-bottom: 5px;
  }
  #prompt-ok-btn {
    background: #333;
    color: #0f0;
    border: 1px solid #0f0;
    cursor: pointer;
    padding: 5px 10px;
    font-family: monospace;
    width: fit-content;
  }
</style>
</head>
<body>
<div id="game-container">
  <div id="output"></div>
  <div id="input-area">
    <input type="text" id="command-input" placeholder="Enter command..." />
    <button id="submit-btn">Submit</button>
  </div>
  <div id="prompt-container">
    <div id="prompt-message"></div>
    <input type="text" id="prompt-input" />
    <button id="prompt-ok-btn">OK</button>
  </div>
</div>
<script>
// ----------------------------
// Utility and UI Functions
// ----------------------------
let outputArea = document.getElementById('output');
let commandInput = document.getElementById('command-input');
let submitBtn = document.getElementById('submit-btn');

let promptContainer = document.getElementById('prompt-container');
let promptMessage = document.getElementById('prompt-message');
let promptInput = document.getElementById('prompt-input');
let promptOkBtn = document.getElementById('prompt-ok-btn');

let promptResolve = null;
function gamePrompt(msg) {
  return new Promise((resolve) => {
    promptResolve = resolve;
    promptMessage.textContent = msg;
    promptInput.value = '';
    promptContainer.style.display = 'flex';
    promptInput.focus();
  });
}
promptOkBtn.addEventListener('click', () => {
  if (promptResolve) {
    let val = promptInput.value;
    promptContainer.style.display = 'none';
    promptResolve(val);
    promptResolve = null;
  }
});

function output(msg) {
  outputArea.textContent += msg + "\n";
  outputArea.scrollTop = outputArea.scrollHeight;
}

// In place of prompt(), we'll use async/await and gamePrompt
async function input(msg) {
  output(msg);
  let val = await gamePrompt(msg);
  return val;
}

// A synchronous-like input function that returns a promise
// We'll rewrite the main loop logic to be async for this to work.

// ----------------------------
// Core Game Code
// ----------------------------

function randInt(max) {
  return Math.floor(Math.random() * max);
}

function clamp(value, min, max) {
  return Math.min(max, Math.max(min, value));
}

const GALAXY_SIZE = 8;
let galaxy = [];
let quadrant = { x: 0, y: 0 };    // Current quadrant coordinates
let sector = { x: 0, y: 0 };      // Current sector coordinates (1-8)
let energy = 3000;
let torpedoes = 10;
let shieldLevel = 0;
let docked = false;
let klingonCount = 0;
let baseCount = 0;
let startStardate = 2000 + randInt(100);
let timeRemaining = 40; // turns/time units
let destroyedKlingons = 0;

let shipDestroyed = false;
let missionCompleted = false;

const EMPTY = ' ';
const ENTERPRISE = 'E';
const KLINGON = 'K';
const STARBASE = 'B';
const STAR = '*';

for (let i = 0; i < GALAXY_SIZE; i++) {
  galaxy[i] = [];
  for (let j = 0; j < GALAXY_SIZE; j++) {
    let klingons = 0; 
    if (Math.random() < 0.2) {
      klingons = 1 + randInt(3);
    }
    let bases = (Math.random() < 0.1) ? 1 : 0; 
    let stars = 1 + randInt(8);
    galaxy[i][j] = {
      klingons: klingons,
      bases: bases,
      stars: stars,
      scanned: false
    };
    klingonCount += klingons;
    baseCount += bases;
  }
}

// Place Enterprise in random quadrant & sector
quadrant.x = randInt(GALAXY_SIZE);
quadrant.y = randInt(GALAXY_SIZE);
sector.x = 1 + randInt(8);
sector.y = 1 + randInt(8);

function placeObject(map, obj) {
  let attempts = 0;
  while (attempts < 1000) {
    let x = randInt(8);
    let y = randInt(8);
    if (map[x][y] === EMPTY) {
      if (!(x === sector.x-1 && y === sector.y-1)) {
        map[x][y] = obj;
        return;
      }
    }
    attempts++;
  }
}

function generateQuadrantMap() {
  let map = [];
  for (let x = 0; x < 8; x++) {
    map[x] = [];
    for (let y = 0; y < 8; y++) {
      map[x][y] = EMPTY;
    }
  }
  
  let qData = galaxy[quadrant.x][quadrant.y];
  map[sector.x-1][sector.y-1] = ENTERPRISE;
  
  for (let k = 0; k < qData.klingons; k++) {
    placeObject(map, KLINGON);
  }
  
  for (let b = 0; b < qData.bases; b++) {
    placeObject(map, STARBASE);
  }
  
  // Place stars
  let totalObjects = 1 + qData.klingons + qData.bases;
  let starCount = qData.stars;
  for (let s = 0; s < starCount; s++) {
    placeObject(map, STAR);
  }
  
  return map;
}

let currentQuadrantMap = generateQuadrantMap();

function printStatus() {
  output(`Stardate: ${startStardate}, Time remaining: ${timeRemaining}`);
  output(`Quadrant: (${quadrant.x+1},${quadrant.y+1}), Sector: (${sector.x},${sector.y})`);
  output(`Energy: ${energy}, Shields: ${shieldLevel}, Torpedoes: ${torpedoes}`);
  output(`Klingons remaining: ${klingonCount}`);
  if (docked) output("You are docked at a Starbase.");
}

function printShortRangeScan() {
  output("Short Range Scan (Quadrant Map):");
  output("   1  2  3  4  5  6  7  8");
  for (let y = 0; y < 8; y++) {
    let line = (y+1) + " ";
    for (let x = 0; x < 8; x++) {
      line += " " + currentQuadrantMap[x][y];
    }
    output(line);
  }
  output("--------------------------------");
}

function longRangeScan() {
  output("Long Range Scan:");
  for (let Y = quadrant.y-1; Y <= quadrant.y+1; Y++) {
    let line = "";
    for (let X = quadrant.x-1; X <= quadrant.x+1; X++) {
      if (X < 0 || X >= GALAXY_SIZE || Y < 0 || Y >= GALAXY_SIZE) {
        line += " *** "; 
      } else {
        let q = galaxy[X][Y];
        line += ` ${q.klingons}${q.bases}${q.stars} `;
        galaxy[X][Y].scanned = true;
      }
    }
    output(line);
  }
}

function damageShip(amount) {
  energy -= amount;
  if (energy <= 0) {
    shipDestroyed = true;
  }
}

function dockIfPossible() {
  for (let dx = -1; dx <= 1; dx++) {
    for (let dy = -1; dy <= 1; dy++) {
      let nx = sector.x-1+dx;
      let ny = sector.y-1+dy;
      if (nx >=0 && nx<8 && ny>=0 && ny<8) {
        if (currentQuadrantMap[nx][ny] === STARBASE) {
          docked = true;
          energy = 3000;
          torpedoes = 10;
          shieldLevel = 0;
          output("Docked at Starbase. Energy and Torpedoes replenished.");
          return;
        }
      }
    }
  }
  docked = false;
}

function moveShip(newQx, newQy, newSx, newSy, warpFactor) {
  let quadrantDistance = Math.sqrt((newQx - quadrant.x)**2 + (newQy - quadrant.y)**2);
  let sectorDistance = Math.sqrt((newSx - sector.x)**2 + (newSy - sector.y)**2);
  let distance = quadrantDistance * 8 + sectorDistance;
  
  let cost = distance * warpFactor * 10;
  if (cost > energy) {
    output("Not enough energy for that maneuver.");
    return false;
  }
  
  energy -= cost;
  
  quadrant.x = clamp(newQx,0,7);
  quadrant.y = clamp(newQy,0,7);
  sector.x = clamp(newSx,1,8);
  sector.y = clamp(newSy,1,8);
  
  currentQuadrantMap = generateQuadrantMap();
  dockIfPossible();
  
  timeRemaining -= 1;
  startStardate += 1;
  return true;
}

function firePhasers(amount) {
  if (amount > energy) {
    output("Insufficient energy in banks.");
    return;
  }
  if (docked) {
    output("Phasers while docked? Undock first.");
    return;
  }
  energy -= amount;
  
  let kPositions = [];
  for (let x = 0; x<8; x++) {
    for (let y=0; y<8; y++) {
      if (currentQuadrantMap[x][y] === KLINGON) {
        kPositions.push({x,y});
      }
    }
  }
  
  if (kPositions.length === 0) {
    output("No Klingons in this quadrant.");
    return;
  }
  
  let portion = amount / kPositions.length;
  let qData = galaxy[quadrant.x][quadrant.y];
  for (let k of kPositions) {
    let damage = portion;
    if (damage > 200) {
      output(`Klingon at sector (${k.x+1},${k.y+1}) destroyed!`);
      currentQuadrantMap[k.x][k.y] = STAR;
      qData.klingons--;
      klingonCount--;
      destroyedKlingons++;
    } else {
      output(`Klingon at (${k.x+1},${k.y+1}) damaged but still operational!`);
      let returnDamage = 50;
      if (shieldLevel > 0) {
        if (shieldLevel >= returnDamage) {
          shieldLevel -= returnDamage;
          output("Shields absorb the return fire.");
        } else {
          let overflow = returnDamage - shieldLevel;
          shieldLevel = 0;
          output("Shields down!");
          damageShip(overflow);
        }
      } else {
        damageShip(returnDamage);
      }
    }
  }
  
  if (klingonCount === 0) {
    missionCompleted = true;
    output("All Klingons destroyed! You have saved the Federation!");
  }
}

function fireTorpedo(tx, ty) {
  if (torpedoes < 1) {
    output("No torpedoes left!");
    return;
  }
  torpedoes--;
  
  tx = tx - 1;
  ty = ty - 1;
  if (tx<0 || tx>7 || ty<0 || ty>7) {
    output("Torpedo missed (out of bounds)!");
    return;
  }
  
  let target = currentQuadrantMap[tx][ty];
  if (target === KLINGON) {
    output("Direct hit! Klingon destroyed.");
    currentQuadrantMap[tx][ty] = STAR;
    let qData = galaxy[quadrant.x][quadrant.y];
    qData.klingons--;
    klingonCount--;
    destroyedKlingons++;
    if (klingonCount === 0) {
      missionCompleted = true;
      output("All Klingons destroyed! You have saved the Federation!");
    }
  } else if (target === STARBASE) {
    output("You hit a starbase! Starfleet will not be pleased.");
    currentQuadrantMap[tx][ty] = STAR;
    let qData = galaxy[quadrant.x][quadrant.y];
    qData.bases--;
    baseCount--;
  } else {
    output("Torpedo missed.");
  }
}

function setShields(amount) {
  if (amount > energy) {
    output("Not enough energy for shields!");
    return;
  }
  shieldLevel = amount;
  energy -= amount;
  output(`Shields set to ${shieldLevel}.`);
}

function checkGameOver() {
  if (shipDestroyed) {
    output("The Enterprise has been destroyed. Game Over.");
    return true;
  }
  if (timeRemaining <= 0 && klingonCount > 0) {
    output("Time has run out before eliminating all Klingons. Game Over.");
    return true;
  }
  if (missionCompleted) {
    output("Congratulations! Mission accomplished!");
    return true;
  }
  return false;
}

async function handleCommand(cmd) {
  cmd = cmd.toUpperCase().trim();
  switch (cmd) {
    case 'NAV':
      {
        let nq = parseInt(await input("Enter new quadrant X (1-8): "),10)-1;
        let mq = parseInt(await input("Enter new quadrant Y (1-8): "),10)-1;
        let nsx = parseInt(await input("Enter new sector X (1-8): "),10);
        let nsy = parseInt(await input("Enter new sector Y (1-8): "),10);
        let wf = parseFloat(await input("Enter warp factor (0.1 to 8): "));
        if (isNaN(nq) || isNaN(mq) || isNaN(nsx) || isNaN(nsy) || isNaN(wf)) {
          output("Invalid navigation parameters.");
          break;
        }
        docked = false;
        moveShip(nq, mq, nsx, nsy, wf);
      }
      break;
    case 'SRS':
      printShortRangeScan();
      break;
    case 'LRS':
      longRangeScan();
      break;
    case 'PHA':
      {
        let amount = parseInt(await input("Enter phaser energy to fire: "),10);
        if (!isNaN(amount) && amount > 0) {
          firePhasers(amount);
        }
      }
      break;
    case 'TOR':
      {
        let tx = parseInt(await input("Torpedo target sector X: "),10);
        let ty = parseInt(await input("Torpedo target sector Y: "),10);
        if (!isNaN(tx) && !isNaN(ty)) {
          fireTorpedo(tx, ty);
        }
      }
      break;
    case 'SHE':
      {
        let lvl = parseInt(await input("Set shield level: "),10);
        if (!isNaN(lvl) && lvl >=0) {
          setShields(lvl);
        }
      }
      break;
    case 'DOC':
      dockIfPossible();
      if (!docked) {
        output("No starbase adjacent to dock.");
      }
      break;
    case 'Q':
      return false;
    default:
      output("Invalid command. Commands: NAV, SRS, LRS, PHA, TOR, SHE, DOC, Q");
  }
  return true;
}

async function gameLoop() {
  output("Welcome to the Classic Star Trek Game!");
  output("Your mission: Destroy all Klingon warships before time runs out.");
  output("Commands: NAV, SRS, LRS, PHA, TOR, SHE, DOC, Q\n");
  
  while (true) {
    if (checkGameOver()) break;
    printStatus();
    let command = await gamePrompt("Command? ");
    promptContainer.style.display = 'none';
    let continueGame = await handleCommand(command);
    if (!continueGame) break;
  }
  
  output("Game ended. Thank you for playing.");
}

// Start the game loop automatically
gameLoop();

// For convenience, pressing Enter on the main command input also triggers submission
submitBtn.addEventListener('click', async () => {
  if (promptResolve) {
    // If we are currently prompting for input
    promptOkBtn.click();
  } else {
    // Otherwise treat the command input as a prompt
    let val = commandInput.value;
    commandInput.value = '';
    if (promptResolve) {
      promptResolve(val);
    } else {
      // If the game is waiting for a command, we do the same
      // Actually, commands are awaited in the gameLoop via gamePrompt
      // So we must trigger that flow:
      promptMessage.textContent = "Command? ";
      promptContainer.style.display = 'none';
      if (promptResolve) {
        promptResolve(val);
      }
    }
  }
});

commandInput.addEventListener('keyup', (e) => {
  if (e.key === 'Enter') {
    submitBtn.click();
  }
});
</script>
</body>
</html>
